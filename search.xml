<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UE4代理</title>
    <url>/2020/03/08/UE4%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="UE4代理"><a href="#UE4代理" class="headerlink" title="UE4代理"></a>UE4代理</h1><p>UE4分为三种代理，单播代理，多播代理，动态代理(支持UObject序列化)<br>代理你可以不知道对象是什么，但是可以执行对象里的函数，前提是需要绑定<br>UE4代理不仅支持原生C++，也支持UObject和共享指针的绑定</p>
<h2 id="单播代理"><a href="#单播代理" class="headerlink" title="单播代理"></a>单播代理</h2><h3 id="绑定C-原生函数"><a href="#绑定C-原生函数" class="headerlink" title="绑定C++原生函数"></a>绑定C++原生函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命名规范都是需要F开始,传入的参数都应该是引用</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE(FDelegateTaskA)</span>;<span class="comment">//创建一个没有任何参数也没有返回值的代理</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE_OneParam(FDelegateTaskB, <span class="params">bool</span>)</span>;<span class="comment">//带一个参数</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE_RetVal(<span class="params">bool</span>, FDelegateTaskC)</span>;<span class="comment">//带返回值但是没有形参</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE_RetVal_OneParam(<span class="params">int32</span>, FDelegateTaskD, FString&amp;)</span>;<span class="comment">//带返回值带一个形参</span></span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="C-Function-h"><a href="#C-Function-h" class="headerlink" title="C_Function.h"></a>C_Function.h</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#<span class="keyword">include</span> <span class="string">"CoreMinimal.h"</span></span><br><span class="line">#<span class="keyword">include</span> <span class="string">"Engine/Engine.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命名规范都是需要F开始,传入的参数都应该是引用</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE(FDelegateTaskA)</span>;<span class="comment">//创建一个没有任何参数也没有返回值的代理</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE_OneParam(FDelegateTaskB, <span class="params">bool</span>)</span>;<span class="comment">//带一个参数</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE_RetVal(<span class="params">bool</span>, FDelegateTaskC)</span>;<span class="comment">//带返回值但是没有形参</span></span><br><span class="line"><span class="constructor">DECLARE_DELEGATE_RetVal_OneParam(<span class="params">int32</span>, FDelegateTaskD, FString&amp;)</span>;<span class="comment">//带返回值带一个形参</span></span><br><span class="line"></span><br><span class="line">static void <span class="constructor">PrintF(FString NewString)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (GEngine)</span><br><span class="line">	&#123;</span><br><span class="line">		GEngine-&gt;<span class="constructor">AddOnScreenDebugMessage(-1, 20, FColor::Red, NewString)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">class</span> ClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	FDelegateTaskA DelegateTaskA;</span><br><span class="line">	FDelegateTaskB DelegateTaskB;</span><br><span class="line">	FDelegateTaskC DelegateTaskC;</span><br><span class="line">	FDelegateTaskD DelegateTaskD;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	<span class="comment">//调用执行代理</span></span><br><span class="line">	void init<span class="literal">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bool</span> IsRight = <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">int32</span> Index = INDEX_NONE;</span><br><span class="line">		FString NewStr = <span class="constructor">TEXT(<span class="string">"Hello World"</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//代理的执行</span></span><br><span class="line">		DelegateTaskA.<span class="constructor">ExecuteIfBound()</span>;</span><br><span class="line">		DelegateTaskB.<span class="constructor">ExecuteIfBound(IsRight)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (DelegateTaskC.<span class="constructor">IsBound()</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			IsRight = DelegateTaskC.<span class="constructor">Execute()</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (DelegateTaskD.<span class="constructor">IsBound()</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Index = DelegateTaskD.<span class="constructor">Execute(NewStr)</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ClassB</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">ClassB(ClassA<span class="operator">*</span> NewClass_a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (NewClass_a)</span><br><span class="line">		&#123;</span><br><span class="line">			m_classA = NewClass_a;</span><br><span class="line"></span><br><span class="line">			m_classA-&gt;DelegateTaskA.<span class="constructor">BindRaw(<span class="params">this</span>, &amp;ClassB::ExecuteA)</span>;</span><br><span class="line">			m_classA-&gt;DelegateTaskB.<span class="constructor">BindRaw(<span class="params">this</span>, &amp;ClassB::ExecuteB)</span>;</span><br><span class="line">			m_classA-&gt;DelegateTaskC.<span class="constructor">BindRaw(<span class="params">this</span>, &amp;ClassB::ExecuteC)</span>;</span><br><span class="line">			m_classA-&gt;DelegateTaskD.<span class="constructor">BindRaw(<span class="params">this</span>, &amp;ClassB::ExecuteD)</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void <span class="constructor">ExecuteA()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="constructor">PrintF(TEXT(<span class="string">"ExecuteA"</span>)</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	void <span class="constructor">ExecuteB(<span class="params">bool</span> <span class="params">isRight</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="constructor">PrintF(TEXT(<span class="string">"ExecuteB"</span>)</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bool</span> <span class="constructor">ExecuteC()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="constructor">PrintF(TEXT(<span class="string">"ExecuteC"</span>)</span>);</span><br><span class="line">		return <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int32</span> <span class="constructor">ExecuteD(FString &amp;<span class="params">cde</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="constructor">PrintF(TEXT(<span class="string">"ExecuteD"</span>)</span>);</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="constructor">ClassB()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_classA)</span><br><span class="line">		&#123;</span><br><span class="line">			m_classA-&gt;DelegateTaskA.<span class="constructor">Unbind()</span>;</span><br><span class="line">			m_classA-&gt;DelegateTaskB.<span class="constructor">Unbind()</span>;</span><br><span class="line">			m_classA-&gt;DelegateTaskC.<span class="constructor">Unbind()</span>;</span><br><span class="line">			m_classA-&gt;DelegateTaskD.<span class="constructor">Unbind()</span>;</span><br><span class="line">			m_classA-&gt;init<span class="literal">()</span>;</span><br><span class="line">			delete m_classA;</span><br><span class="line">			m_classA = nullptr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ClassA* m_classA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="MainActor-cpp"><a href="#MainActor-cpp" class="headerlink" title="MainActor.cpp"></a>MainActor.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MainActor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"C_Function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMainActor::AMainActor()</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.</span></span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMainActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::BeginPlay();</span><br><span class="line">	ClassA* NewClassA = <span class="keyword">new</span> ClassA();</span><br><span class="line">	ClassB* NewClassB = <span class="keyword">new</span> ClassB(NewClassA);</span><br><span class="line">	NewClassA-&gt;init();</span><br><span class="line">	<span class="keyword">delete</span> NewClassB;</span><br><span class="line">	NewClassA = <span class="literal">nullptr</span>;</span><br><span class="line">	NewClassB = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMainActor::Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::Tick(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>UE4强引用和弱引用</title>
    <url>/2020/03/08/UE4%E5%BC%BA%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>能有效避免野指针</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Math/UnrealMathUtility.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ID</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IMyID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IMyID()</span><br><span class="line">	&#123;</span><br><span class="line">		ID = FMath::RandRange(<span class="number">100</span>, <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	uint64 ID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FData_</span> :</span> <span class="keyword">public</span> IMyID</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">float</span> Health;</span><br><span class="line">	uint8 bDeath : <span class="number">1</span>;</span><br><span class="line">	FName PlayerName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据管理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FDataManage_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">TSharedPtr&lt;FDataManage_&gt; <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (! DataManage.IsValid())</span><br><span class="line">		&#123;</span><br><span class="line">			DataManage = MakeShareable(<span class="keyword">new</span> FDataManage_());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> DataManage.ToSharedRef();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> TSharedPtr&lt;FDataManage_&gt; DataManage;</span><br><span class="line"></span><br><span class="line">	TMap&lt;uint64, TSharedPtr&lt;FData_&gt;&gt; MyData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TWeakPtr&lt;FData_&gt; NewData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m_NewMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE4</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4弱指针</title>
    <url>/2020/03/07/UE4%E5%BC%B1%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="弱指针"><a href="#弱指针" class="headerlink" title="弱指针"></a>弱指针</h1><p>弱指针 存储对象的弱引用。与 共享指针 或 共享引用 不同，弱指针不会阻止其引用的对象被销毁。</p>
<p>在访问弱指针引用的对象前，应使用 Pin 函数生成共享指针。此操作确保使用该对象时其将继续存在。如只需要确定弱指针是否引用对象，可将其与 nullptr 比较，或在之上调用 IsValid。</p>
<p>弱指针的使用有助于授予意图——弱指针表明对引用对象的观察，而无需所有权，同时不控制其生命周期。</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">TWeakPtr&lt;TaskA&gt; Task_B;</span><br><span class="line">void AMyActor::<span class="constructor">TaskTweakPtr()</span></span><br><span class="line">&#123;</span><br><span class="line">	TSharedPtr&lt;TaskA&gt; _TaskA_Ptr = <span class="constructor">MakeShareable(<span class="params">new</span> TaskA()</span>);</span><br><span class="line">	TSharedRef&lt;TaskA&gt; <span class="constructor">_TaskA_Ref(<span class="params">new</span> TaskA()</span>);</span><br><span class="line"></span><br><span class="line">	TWeakPtr&lt;TaskA&gt; <span class="constructor">Task_D(<span class="params">_TaskA_Ptr</span>)</span>;</span><br><span class="line">	TWeakPtr&lt;TaskA&gt; <span class="constructor">Task_K(<span class="params">_TaskA_Ref</span>)</span>;</span><br><span class="line"></span><br><span class="line">	Task_B = Task_D;</span><br><span class="line"></span><br><span class="line">	Task_B = Task_K;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弱指针转共享指针"><a href="#弱指针转共享指针" class="headerlink" title="弱指针转共享指针"></a>弱指针转共享指针</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">TSharedPtr&lt;TaskA&gt; NewTaskA(Task_B.Pin())<span class="comment">;</span></span><br><span class="line">if (NewTaskA.IsValid())</span><br><span class="line">	&#123;</span><br><span class="line">		NewTaskA.Get-&gt;a<span class="comment">;</span></span><br><span class="line">		NewTaskA.Reset()<span class="comment">;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h2><p>(<a href="https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/SmartPointerLibrary/WeakPointer/index.html" target="_blank" rel="noopener">https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/SmartPointerLibrary/WeakPointer/index.html</a>)</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">class FTreeNode &#123;</span><br><span class="line">	TArray&lt;TSharedPtr&lt;FTreeNode&gt;&gt; Children<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	TWeakPtr&lt;FTreeNode&gt; Parent<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE4</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4共享引用</title>
    <url>/2020/03/07/UE4%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="共享引用"><a href="#共享引用" class="headerlink" title="共享引用"></a>共享引用</h1><p>共享引用和共享指针的区别就是一直有效，共享指针可以被设为Null,而共享指针被一创建出来就会一直有用，只要存在就一定有效</p>
<a id="more"></a>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyActor::TaskBB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TSharedRef&lt;TaskA&gt; <span class="title">Task_B</span><span class="params">(<span class="keyword">new</span> TaskA())</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用共享引用是非常安全的,不用怕其他时候会被设置会NULL<br>两种访问方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyActor::TaskBB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TSharedRef&lt;TaskA&gt; <span class="title">Task_B</span><span class="params">(<span class="keyword">new</span> TaskA())</span></span>;</span><br><span class="line">    Task_B-&gt;a;</span><br><span class="line">    (*Task_B).a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享引用转共享指针"><a href="#共享引用转共享指针" class="headerlink" title="共享引用转共享指针"></a>共享引用转共享指针</h2><p>共享引用转共享指针可以直接转换,支持隐式转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyActor::TaskShaerdRefAndPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TSharedRef&lt;TaskA&gt; <span class="title">Task_B</span><span class="params">(<span class="keyword">new</span> TaskA())</span></span>;</span><br><span class="line">	Task_A = Task_B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享指针转共享引用"><a href="#共享指针转共享引用" class="headerlink" title="共享指针转共享引用"></a>共享指针转共享引用</h2><p>共享指针转共享引用是不安全的,因为里面有个断言,如果这个断言出现问题,那么程序就会崩溃</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyActor::TaskShaerdRefAndPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TSharedRef&lt;TaskA&gt; <span class="title">Task_B</span><span class="params">(<span class="keyword">new</span> TaskA())</span></span>;</span><br><span class="line">	Task_A = Task_B;</span><br><span class="line"></span><br><span class="line">	Task_B = Task_A.ToSharedRef();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UE4</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4共享指针</title>
    <url>/2020/03/06/UE4%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="共享指针"><a href="#共享指针" class="headerlink" title="共享指针"></a>共享指针</h1><p>共享引用 是一类强大且不可为空的 智能指针，其被用于引擎的 Uobject 系统外的数据对象。此意味无法重置共享引用、向其指定空对象，或创建空白引用。因此共享引用固定包含有效对象，甚至未拥有 IsValid 方法。在共享引用和 [共享指针]（Shared Pointers） 间选择时，除非需要空白或可为空的对象，否则共享引用为优先选项。如需可能空白或可为空的引用，则应使用共享指针。<br>与标准的C++引用不同，可在创建后将共享引用重新指定到另一对象。</p>
<a id="more"></a>

<p>继承至UObject,会被回收,只有不是继承至UObject的才需要共享指针</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">TSharedPtr<span class="params">&lt;AActor&gt;</span><span class="comment">//这样是矛盾的，不兼容的,因为AActor继承至UObject会被智能回收掉</span></span><br></pre></td></tr></table></figure>
<p>如果不是继承至UObject的class，一定要用共享指针,共享指针是不可以被复制的,智能指针是可以等于NULL的</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">TaskA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">int</span>32 a;</span><br><span class="line">	<span class="built_in">float</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">DEBUGPJ_API</span> <span class="symbol">AMyActor</span> : <span class="symbol">public</span> <span class="symbol">AActor</span></span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_BODY()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">// Sets default values for this actor's properties</span></span><br><span class="line">	AMyActor();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">	virtual <span class="built_in">void</span> BeginPlay() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">// Called every frame</span></span><br><span class="line">	virtual <span class="built_in">void</span> Tick(<span class="built_in">float</span> DeltaTime) <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">	TSharedPtr&lt;TaskA&gt; Task_A;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">TSharedPtr&lt;TaskA&gt; Task_A<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在使用TArray时一定要把不可复制性带进去</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">TArray<span class="attribute">&lt;TSharedPtr&lt;TaskA&gt;</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>先判断是否有效,在调用里面内容的时候，最好是Task_A.Get()-&gt;a;,如果直接用Task_A-&gt;a;,会容易引发崩溃-&gt;操作符重载了一个check的断言</p>
<p><img src="/images/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_1.png" alt="智能指针_1"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AMyActor::<span class="constructor">TaskAA()</span></span><br><span class="line">&#123;</span><br><span class="line">	Task_A = <span class="constructor">MakeShareable(<span class="params">new</span> TaskA()</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Task_A.<span class="constructor">IsValid()</span><span class="operator"> || </span>Task_A.<span class="constructor">Get()</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Task_A.<span class="constructor">Get()</span>-&gt;a;</span><br><span class="line">		<span class="comment">//Task_A-&gt;a;</span></span><br><span class="line">		<span class="comment">//销毁</span></span><br><span class="line">		Task_A.<span class="constructor">Reset()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通指针转共享指针"><a href="#普通指针转共享指针" class="headerlink" title="普通指针转共享指针"></a>普通指针转共享指针</h3><p>用MakeShareable</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">TaskA* NewTaskA = new TaskA()<span class="comment">;</span></span><br><span class="line">Task_A = MakeShareable(<span class="name">NewTaskA</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE4</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4断言</title>
    <url>/2020/03/06/UE4%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>官方链接：(<a href="https://docs.unrealengine.com/zh-CN/Programming/Assertions/index.html" target="_blank" rel="noopener">https://docs.unrealengine.com/zh-CN/Programming/Assertions/index.html</a>)</p>
<p>断言是一种工具，用于确认一段给定代码所依赖的假设。简单而言，它可确认指针不为 NULL；复杂而言，它可确认特定函数无法被重新进入。UE4 提供一系列宏，以执行这些类型的确认。它们为宏，以便在特定编译配置中进行译出（出于性能因素或因为最终版本中不需要它们）。在以下路径中可查看宏：<br>/UE4/Engine/Source/Runtime/Core/Public/Misc/AssertionMacros.h.<br>运行时断言宏有三种类型：停止执行、在调试版本中停止执行和不停止执行报告错误。第一种和第三种类型的编译取决于 DO_CHECK 定义。第二种类型的编译使用 DO_GUARD_SLOW 定义。如任意定义设为 0，宏将被禁用且不影响执行。<br>我们一起来看看断言宏的第一类。如断言不为 true，以下宏将全部停止执行。如在调试器中运行，断言将导致断点的出现，以便查看如何到达此点。</p>
<a id="more"></a>
<h2 id="check"><a href="#check" class="headerlink" title="check"></a>check</h2><p>check()中填入false或0或NULL都会被断掉</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">AActor* Test = nullptr<span class="comment">;</span></span><br><span class="line">check(<span class="name">Test</span> <span class="symbol">&amp;&amp;</span> <span class="string">"Test 不能为空指针"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="verifyf"><a href="#verifyf" class="headerlink" title="verifyf"></a>verifyf</h2><p>verifyf和check完全相同</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">verify(<span class="name">Test</span> != nullptr)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="checkf"><a href="#checkf" class="headerlink" title="checkf"></a>checkf</h2><p>checkf和check完全相同,在调试时可以打印额外的信息</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">checkf</span><span class="params">(Test, TEXT(<span class="string">"Test &amp;s"</span>)</span>, *<span class="title">this</span>-&gt;</span>GetName());</span><br></pre></td></tr></table></figure>
<h2 id="checkNoentry"><a href="#checkNoentry" class="headerlink" title="checkNoentry"></a>checkNoentry</h2><p>进入当前函数就会被断掉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn_huauha::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Super::BeginPlay();</span></span><br><span class="line">	checkNoEntry();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="checkNoReentry"><a href="#checkNoReentry" class="headerlink" title="checkNoReentry"></a>checkNoReentry</h2><p>会检测当前函数是否执行了两次，第一次运行是没有问题的，第二次运行就会被断掉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyPawn_huauha::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Super::BeginPlay();</span></span><br><span class="line">	checkNoReentry();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="checkNoRecursion"><a href="#checkNoRecursion" class="headerlink" title="checkNoRecursion"></a>checkNoRecursion</h2><p>检测当前函数有没有递归，如果有就会被断掉</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="variable">AMyPawn_huauha</span>::<span class="function"><span class="title">BeginPlay</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Super::BeginPlay();</span></span><br><span class="line">	<span class="function"><span class="title">checkNoRecursion</span>();</span></span><br><span class="line"><span class="function">	<span class="title">BeginPlay</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="ensure"><a href="#ensure" class="headerlink" title="ensure"></a>ensure</h2><p>类似于断点,不是直接崩溃,而是生成一个断点,可以继续往下走,用法和check一样</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">ensure(<span class="number">0</span> <span class="symbol">&amp;&amp;</span> <span class="string">"Test"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="ensureMsgf"><a href="#ensureMsgf" class="headerlink" title="ensureMsgf"></a>ensureMsgf</h2><p>类似于断点,不是直接崩溃,而是生成一个断点,可以继续往下走,用法和checkf一样,这两个和check最大的不同就是程序不会崩溃</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ensureMsgf</span><span class="params">(<span class="number">0</span> TEXT(<span class="string">"%s"</span>)</span>,<span class="title">this</span>-&gt;</span>GetName());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE4</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4游戏架构</title>
    <url>/2020/03/06/UE4%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="UE4MMoRPG游戏-Online"><a href="#UE4MMoRPG游戏-Online" class="headerlink" title="UE4MMoRPG游戏(Online)"></a>UE4MMoRPG游戏(Online)</h1><p>客户端其实就是对服务端一个粗略的模范</p>
<h2 id="World"><a href="#World" class="headerlink" title="World"></a>World</h2><p>一个容器,容器里容纳了所有物体,这些物体都有一个特点就是继承至Actor</p>
<h3 id="GameLnstance"><a href="#GameLnstance" class="headerlink" title="GameLnstance"></a>GameLnstance</h3><p>一个游戏的实例,凌驾于所有游戏之上,再切换关卡的时候GameLnstance里的数据依然保留,需要在切换关卡保留的数据可以存放在GameLnstance</p>
<a id="more"></a>
<h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p>GameMode如果在联网状态下是一个服务端(Server),客户端不能访问</p>
<h3 id="GameSession"><a href="#GameSession" class="headerlink" title="GameSession"></a>GameSession</h3><p>GameSession更像一个房间,让玩家进入,加入游戏,存在于服务端</p>
<h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><p>GameState相当于一个全局的数据管理,在客户端也存在一份，可以和客户端实时同步,可以被客户端和服务端访问</p>
<h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><p>PlayerController是非常重要的,它关联着服务端和客户端,客户端是通过Controller来向服务端发请求,用它来控制Pawn<br>包含:<br>    输出响应控制<br>    旁观者<br>    替换角色<br>    网络连接<br>    GM命令<br>    声音<br>    语言<br>    射线<br>    客户端显示HUD<br>    视口<br>    相机管理<br>    屏幕震动<br>    作弊管理<br>    客户端和服务端都存在<br>    执行客户端逻辑和服务端逻辑请求</p>
<h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><p>掌管玩家的一些数据，一个角色的攻击力,防御力,Buff以及其他的一些数据,需要通过PlayerController来访问</p>
<h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><p>Pawn也需要PlayerController来访问,Pawn其实是一个角色的表现,比如动画,模型以及其他组件,Pawn也是客户端和服务端都存在一份</p>
<h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><p>HUD只存在于客户端,服务端是没有这个东西的,用来做UMG或者Slate的管理</p>
<h3 id="GameViewoirtClient"><a href="#GameViewoirtClient" class="headerlink" title="GameViewoirtClient"></a>GameViewoirtClient</h3><p>GameViewoirtClient是一个游戏视口,在游戏中只存在于客户端,输出响应和渲染</p>
<h3 id="GameUserSettings"><a href="#GameUserSettings" class="headerlink" title="GameUserSettings"></a>GameUserSettings</h3><p>GameUserSettings可以做些配置，自定义的一些配置</p>
<h3 id="WorldSettings"><a href="#WorldSettings" class="headerlink" title="WorldSettings"></a>WorldSettings</h3><p>调节当前关卡的属性</p>
]]></content>
      <categories>
        <category>UE4</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UPROPERTY</title>
    <url>/2020/03/06/Unreal-UPROPERTY/</url>
    <content><![CDATA[<h1 id="UPROPERTY"><a href="#UPROPERTY" class="headerlink" title="UPROPERTY"></a>UPROPERTY</h1><p>UPROPERTY 用途广泛,它允许变量被复制、被序列化，并可从蓝图中进行访问.垃圾回收器还使用它们来追踪对 UObject 的引用数.</p>
<a id="more"></a>
<h2 id="属性说明符"><a href="#属性说明符" class="headerlink" title="属性说明符"></a>属性说明符</h2><p>声明属性时,属性说明符,可被添加到声明,以控制属性与引擎和编辑器诸多方面的相处方式.</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">Category=<span class="string">"TopCategory|SubCategory|..."</span> <span class="comment">// 指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。</span></span><br><span class="line"><span class="symbol">UP:</span>:AdvancedDisplay <span class="comment">// 属性将被放置在其出现的任意面板的高级（下拉）部分中。</span></span><br><span class="line"><span class="symbol">UP:</span>:AssetRegistrySearchable <span class="comment">// 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用</span></span><br><span class="line"><span class="symbol">UP:</span>:BlueprintAssignable <span class="comment">// 只能与组播委托共用。公开属性在蓝图中指定。</span></span><br><span class="line"><span class="symbol">UP:</span>:BlueprintAuthorityOnly <span class="comment">// 此属性必须为一个组播委托。在蓝图中，其只接受带 BlueprintAuthorityOnly 标签的事件。</span></span><br><span class="line"><span class="symbol">UP:</span>:BlueprintCallable <span class="comment">// 仅用于组播委托。应公开属性在蓝图代码中调用。</span></span><br><span class="line"><span class="symbol">UP:</span>:BlueprintReadOnly <span class="comment">// 此属性可由蓝图读取，但不能被修改。此说明符与 BlueprintReadWrite 说明符不兼容。</span></span><br><span class="line"><span class="symbol">UP:</span>:BlueprintReadWrite <span class="comment">// 可从蓝图读取或写入此属性。此说明符与 BlueprintReadOnly 说明符不兼容。</span></span><br><span class="line"><span class="symbol">UP:</span>:VisibleAnywhere <span class="comment">// 说明此属性在所有属性窗口中可见，但无法被编辑。此说明符与“Edit”说明符不兼容。</span></span><br><span class="line"><span class="symbol">UP:</span>:VisibleDefaultsOnly <span class="comment">// 说明此属性只在原型的属性窗口中可见，无法被编辑。此说明符与所有“Edit”说明符均不兼容。</span></span><br><span class="line"><span class="symbol">UP:</span>:VisibleInstanceOnly <span class="comment">// 说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），无法被编辑。此说明符与所有“Edit”说明符均不兼容。</span></span><br></pre></td></tr></table></figure>
<h2 id="元数据说明符"><a href="#元数据说明符" class="headerlink" title="元数据说明符"></a>元数据说明符</h2><p>声明类,接口,结构体,列举,列举值,函数,或属性时,可添加 元数据说明符 来控制其与引擎和编辑器各方面的相处方式。每一种类型的数据结构或成员都有自己的元数据说明符列表。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">DisplayName=<span class="string">"Property Name"</span> <span class="comment">// 此属性显示的命名，不显示代码生成的命名。</span></span><br><span class="line">AllowPreserveRatio <span class="comment">// 用于 Fvector 属性。在细节面板中显示此属性时将添加一个比率锁。</span></span><br></pre></td></tr></table></figure>


<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="VisibleAnywhere"><a href="#VisibleAnywhere" class="headerlink" title="VisibleAnywhere"></a>VisibleAnywhere</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">UPROPERTY(<span class="name">VisibleAnywhere</span>, Category = <span class="string">"Test"</span>)</span><br><span class="line">    bool Test<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/UPROPERTY_1.png" alt="UPROPERTY_1"></p>
<h3 id="VisibleDefaultsOnly"><a href="#VisibleDefaultsOnly" class="headerlink" title="VisibleDefaultsOnly"></a>VisibleDefaultsOnly</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">UPROPERTY(<span class="name">VisibleDefaultsOnly</span>, Category = <span class="string">"Test"</span>)</span><br><span class="line">    bool Test<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/UPROPERTY_2.png" alt="UPROPERTY_1"></p>
<h3 id="VisibleInstanceOnly"><a href="#VisibleInstanceOnly" class="headerlink" title="VisibleInstanceOnly"></a>VisibleInstanceOnly</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">UPROPERTY(<span class="name">VisibleInstanceOnly</span>, Category = <span class="string">"Test"</span>)</span><br><span class="line">    bool Test<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/UPROPERTY_3.png" alt="UPROPERTY_1"></p>
<h3 id="BlueprintReadWrite"><a href="#BlueprintReadWrite" class="headerlink" title="BlueprintReadWrite"></a>BlueprintReadWrite</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">UPROPERTY</span>(<span class="keyword">BlueprintReadWrite, </span>Category = <span class="string">"Test"</span>)</span><br><span class="line">    <span class="keyword">bool </span>Test<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/UPROPERTY_4.png" alt="UPROPERTY_1"></p>
<h2 id="官方链接"><a href="#官方链接" class="headerlink" title="官方链接"></a><a href="https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/Reference/Properties/index.html" target="_blank" rel="noopener">官方链接</a></h2>]]></content>
      <categories>
        <category>UE4</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>UPROPERTY</tag>
      </tags>
  </entry>
</search>

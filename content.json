{"meta":{"title":"萌新小强的Unreal日常","subtitle":"Unreal是世界上最好的引擎","description":"人类的悲欢并不相通，我只觉得他们吵闹","author":"萌新小强","url":"https://mengxinxiaoqiang.github.io","root":"/"},"pages":[{"title":"about","date":"2020-03-05T14:58:38.000Z","updated":"2020-03-05T06:59:47.688Z","comments":true,"path":"about/index.html","permalink":"https://mengxinxiaoqiang.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-05T14:59:01.000Z","updated":"2020-03-05T07:11:25.763Z","comments":true,"path":"categories/index.html","permalink":"https://mengxinxiaoqiang.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-05T14:58:55.000Z","updated":"2020-03-05T07:14:31.301Z","comments":true,"path":"tags/index.html","permalink":"https://mengxinxiaoqiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"UE4代理","slug":"UE4代理","date":"2020-03-08T14:34:26.000Z","updated":"2020-03-08T06:34:26.966Z","comments":true,"path":"2020/03/08/UE4代理/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/08/UE4%E4%BB%A3%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"UE4强引用和弱引用","slug":"UE4强引用和弱引用","date":"2020-03-08T14:18:11.000Z","updated":"2020-03-08T06:34:05.231Z","comments":true,"path":"2020/03/08/UE4强引用和弱引用/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/08/UE4%E5%BC%BA%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8/","excerpt":"能有效避免野指针","text":"能有效避免野指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#pragma once#include \"CoreMinimal.h\"#include \"Math/UnrealMathUtility.h\"//IDclass IMyID&#123;public: IMyID() &#123; ID = FMath::RandRange(100, 1000); &#125;private: uint64 ID;&#125;;//数据class FData_ : public IMyID&#123;public: float Health; uint8 bDeath : 1; FName PlayerName;&#125;;//数据管理class FDataManage_&#123;public: TSharedPtr&lt;FDataManage_&gt; Get() &#123; if (! DataManage.IsValid()) &#123; DataManage = MakeShareable(new FDataManage_()); &#125; return DataManage.ToSharedRef(); &#125;private: static TSharedPtr&lt;FDataManage_&gt; DataManage; TMap&lt;uint64, TSharedPtr&lt;FData_&gt;&gt; MyData;&#125;;class FCharacter&#123;private: TWeakPtr&lt;FData_&gt; NewData;&#125;;void m_NewMain()&#123;&#125;","categories":[{"name":"UE4","slug":"UE4","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/"},{"name":"笔记","slug":"UE4/笔记","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://mengxinxiaoqiang.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"UE4弱指针","slug":"UE4弱指针","date":"2020-03-06T17:04:07.000Z","updated":"2020-03-06T09:28:07.992Z","comments":true,"path":"2020/03/07/UE4弱指针/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/07/UE4%E5%BC%B1%E6%8C%87%E9%92%88/","excerpt":"弱指针弱指针 存储对象的弱引用。与 共享指针 或 共享引用 不同，弱指针不会阻止其引用的对象被销毁。 在访问弱指针引用的对象前，应使用 Pin 函数生成共享指针。此操作确保使用该对象时其将继续存在。如只需要确定弱指针是否引用对象，可将其与 nullptr 比较，或在之上调用 IsValid。 弱指针的使用有助于授予意图——弱指针表明对引用对象的观察，而无需所有权，同时不控制其生命周期。","text":"弱指针弱指针 存储对象的弱引用。与 共享指针 或 共享引用 不同，弱指针不会阻止其引用的对象被销毁。 在访问弱指针引用的对象前，应使用 Pin 函数生成共享指针。此操作确保使用该对象时其将继续存在。如只需要确定弱指针是否引用对象，可将其与 nullptr 比较，或在之上调用 IsValid。 弱指针的使用有助于授予意图——弱指针表明对引用对象的观察，而无需所有权，同时不控制其生命周期。 定义12345678910111213TWeakPtr&lt;TaskA&gt; Task_B;void AMyActor::TaskTweakPtr()&#123; TSharedPtr&lt;TaskA&gt; _TaskA_Ptr = MakeShareable(new TaskA()); TSharedRef&lt;TaskA&gt; _TaskA_Ref(new TaskA()); TWeakPtr&lt;TaskA&gt; Task_D(_TaskA_Ptr); TWeakPtr&lt;TaskA&gt; Task_K(_TaskA_Ref); Task_B = Task_D; Task_B = Task_K;&#125; 弱指针转共享指针123456TSharedPtr&lt;TaskA&gt; NewTaskA(Task_B.Pin());if (NewTaskA.IsValid()) &#123; NewTaskA.Get-&gt;a; NewTaskA.Reset(); &#125; 官方案例(https://docs.unrealengine.com/zh-CN/Programming/UnrealArchitecture/SmartPointerLibrary/WeakPointer/index.html) 12345class FTreeNode &#123; TArray&lt;TSharedPtr&lt;FTreeNode&gt;&gt; Children; TWeakPtr&lt;FTreeNode&gt; Parent;&#125;;","categories":[{"name":"UE4","slug":"UE4","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/"},{"name":"笔记","slug":"UE4/笔记","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://mengxinxiaoqiang.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"UE4共享引用","slug":"UE4共享引用","date":"2020-03-06T16:30:17.000Z","updated":"2020-03-06T08:54:55.739Z","comments":true,"path":"2020/03/07/UE4共享引用/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/07/UE4%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8/","excerpt":"共享引用共享引用和共享指针的区别就是一直有效，共享指针可以被设为Null,而共享指针被一创建出来就会一直有用，只要存在就一定有效","text":"共享引用共享引用和共享指针的区别就是一直有效，共享指针可以被设为Null,而共享指针被一创建出来就会一直有用，只要存在就一定有效 声明12345void AMyActor::TaskBB()&#123; TSharedRef&lt;TaskA&gt; Task_B(new TaskA());&#125; 使用使用共享引用是非常安全的,不用怕其他时候会被设置会NULL两种访问方式 123456void AMyActor::TaskBB()&#123; TSharedRef&lt;TaskA&gt; Task_B(new TaskA()); Task_B-&gt;a; (*Task_B).a;&#125; 共享引用转共享指针共享引用转共享指针可以直接转换,支持隐式转换 12345void AMyActor::TaskShaerdRefAndPtr()&#123; TSharedRef&lt;TaskA&gt; Task_B(new TaskA()); Task_A = Task_B;&#125; 共享指针转共享引用共享指针转共享引用是不安全的,因为里面有个断言,如果这个断言出现问题,那么程序就会崩溃 1234567void AMyActor::TaskShaerdRefAndPtr()&#123; TSharedRef&lt;TaskA&gt; Task_B(new TaskA()); Task_A = Task_B; Task_B = Task_A.ToSharedRef();&#125;","categories":[{"name":"UE4","slug":"UE4","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/"},{"name":"笔记","slug":"UE4/笔记","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://mengxinxiaoqiang.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"UE4共享指针","slug":"UE4共享指针","date":"2020-03-06T15:41:55.000Z","updated":"2020-03-06T08:47:34.993Z","comments":true,"path":"2020/03/06/UE4共享指针/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/06/UE4%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88/","excerpt":"共享指针共享引用 是一类强大且不可为空的 智能指针，其被用于引擎的 Uobject 系统外的数据对象。此意味无法重置共享引用、向其指定空对象，或创建空白引用。因此共享引用固定包含有效对象，甚至未拥有 IsValid 方法。在共享引用和 [共享指针]（Shared Pointers） 间选择时，除非需要空白或可为空的对象，否则共享引用为优先选项。如需可能空白或可为空的引用，则应使用共享指针。与标准的C++引用不同，可在创建后将共享引用重新指定到另一对象。","text":"共享指针共享引用 是一类强大且不可为空的 智能指针，其被用于引擎的 Uobject 系统外的数据对象。此意味无法重置共享引用、向其指定空对象，或创建空白引用。因此共享引用固定包含有效对象，甚至未拥有 IsValid 方法。在共享引用和 [共享指针]（Shared Pointers） 间选择时，除非需要空白或可为空的对象，否则共享引用为优先选项。如需可能空白或可为空的引用，则应使用共享指针。与标准的C++引用不同，可在创建后将共享引用重新指定到另一对象。 继承至UObject,会被回收,只有不是继承至UObject的才需要共享指针 1TSharedPtr&lt;AActor&gt;//这样是矛盾的，不兼容的,因为AActor继承至UObject会被智能回收掉 如果不是继承至UObject的class，一定要用共享指针,共享指针是不可以被复制的,智能指针是可以等于NULL的 12345678910111213141516171819202122232425262728class TaskA&#123;public: int32 a; float b;&#125;;UCLASS()class DEBUGPJ_API AMyActor : public AActor&#123; GENERATED_BODY() public: // Sets default values for this actor's properties AMyActor();protected: // Called when the game starts or when spawned virtual void BeginPlay() override;public: // Called every frame virtual void Tick(float DeltaTime) override; TSharedPtr&lt;TaskA&gt; Task_A;&#125;; 声明1TSharedPtr&lt;TaskA&gt; Task_A; 在使用TArray时一定要把不可复制性带进去 1TArray&lt;TSharedPtr&lt;TaskA&gt;&gt; 使用先判断是否有效,在调用里面内容的时候，最好是Task_A.Get()-&gt;a;,如果直接用Task_A-&gt;a;,会容易引发崩溃-&gt;操作符重载了一个check的断言 123456789101112void AMyActor::TaskAA()&#123; Task_A = MakeShareable(new TaskA()); if (Task_A.IsValid() || Task_A.Get()) &#123; Task_A.Get()-&gt;a; //Task_A-&gt;a; //销毁 Task_A.Reset(); &#125;&#125; 普通指针转共享指针用MakeShareable 12TaskA* NewTaskA = new TaskA();Task_A = MakeShareable(NewTaskA);","categories":[{"name":"UE4","slug":"UE4","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/"},{"name":"笔记","slug":"UE4/笔记","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://mengxinxiaoqiang.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"UE4断言","slug":"UE4断言","date":"2020-03-06T15:16:08.000Z","updated":"2020-03-06T07:46:02.697Z","comments":true,"path":"2020/03/06/UE4断言/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/06/UE4%E6%96%AD%E8%A8%80/","excerpt":"断言官方链接：(https://docs.unrealengine.com/zh-CN/Programming/Assertions/index.html) 断言是一种工具，用于确认一段给定代码所依赖的假设。简单而言，它可确认指针不为 NULL；复杂而言，它可确认特定函数无法被重新进入。UE4 提供一系列宏，以执行这些类型的确认。它们为宏，以便在特定编译配置中进行译出（出于性能因素或因为最终版本中不需要它们）。在以下路径中可查看宏：/UE4/Engine/Source/Runtime/Core/Public/Misc/AssertionMacros.h.运行时断言宏有三种类型：停止执行、在调试版本中停止执行和不停止执行报告错误。第一种和第三种类型的编译取决于 DO_CHECK 定义。第二种类型的编译使用 DO_GUARD_SLOW 定义。如任意定义设为 0，宏将被禁用且不影响执行。我们一起来看看断言宏的第一类。如断言不为 true，以下宏将全部停止执行。如在调试器中运行，断言将导致断点的出现，以便查看如何到达此点。","text":"断言官方链接：(https://docs.unrealengine.com/zh-CN/Programming/Assertions/index.html) 断言是一种工具，用于确认一段给定代码所依赖的假设。简单而言，它可确认指针不为 NULL；复杂而言，它可确认特定函数无法被重新进入。UE4 提供一系列宏，以执行这些类型的确认。它们为宏，以便在特定编译配置中进行译出（出于性能因素或因为最终版本中不需要它们）。在以下路径中可查看宏：/UE4/Engine/Source/Runtime/Core/Public/Misc/AssertionMacros.h.运行时断言宏有三种类型：停止执行、在调试版本中停止执行和不停止执行报告错误。第一种和第三种类型的编译取决于 DO_CHECK 定义。第二种类型的编译使用 DO_GUARD_SLOW 定义。如任意定义设为 0，宏将被禁用且不影响执行。我们一起来看看断言宏的第一类。如断言不为 true，以下宏将全部停止执行。如在调试器中运行，断言将导致断点的出现，以便查看如何到达此点。 checkcheck()中填入false或0或NULL都会被断掉 12AActor* Test = nullptr;check(Test &amp;&amp; \"Test 不能为空指针\"); verifyfverifyf和check完全相同 1verify(Test != nullptr); checkfcheckf和check完全相同,在调试时可以打印额外的信息 1checkf(Test, TEXT(\"Test &amp;s\"), *this-&gt;GetName()); checkNoentry进入当前函数就会被断掉 123456void AMyPawn_huauha::BeginPlay()&#123; //Super::BeginPlay(); checkNoEntry(); &#125; checkNoReentry会检测当前函数是否执行了两次，第一次运行是没有问题的，第二次运行就会被断掉 123456void AMyPawn_huauha::BeginPlay()&#123; //Super::BeginPlay(); checkNoReentry(); &#125; checkNoRecursion检测当前函数有没有递归，如果有就会被断掉 123456void AMyPawn_huauha::BeginPlay()&#123; //Super::BeginPlay(); checkNoRecursion(); BeginPlay();&#125; ensure类似于断点,不是直接崩溃,而是生成一个断点,可以继续往下走,用法和check一样 1ensure(0 &amp;&amp; \"Test\"); ensureMsgf类似于断点,不是直接崩溃,而是生成一个断点,可以继续往下走,用法和checkf一样,这两个和check最大的不同就是程序不会崩溃 1ensureMsgf(0 TEXT(\"%s\"),this-&gt;GetName());","categories":[{"name":"UE4","slug":"UE4","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/"},{"name":"笔记","slug":"UE4/笔记","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://mengxinxiaoqiang.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"UE4游戏架构","slug":"UE4游戏架构","date":"2020-03-06T13:11:42.000Z","updated":"2020-03-06T06:05:57.900Z","comments":true,"path":"2020/03/06/UE4游戏架构/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/06/UE4%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84/","excerpt":"UE4MMoRPG游戏(Online)客户端其实就是对服务端一个粗略的模范 World一个容器,容器里容纳了所有物体,这些物体都有一个特点就是继承至Actor GameLnstance一个游戏的实例,凌驾于所有游戏之上,再切换关卡的时候GameLnstance里的数据依然保留,需要在切换关卡保留的数据可以存放在GameLnstance","text":"UE4MMoRPG游戏(Online)客户端其实就是对服务端一个粗略的模范 World一个容器,容器里容纳了所有物体,这些物体都有一个特点就是继承至Actor GameLnstance一个游戏的实例,凌驾于所有游戏之上,再切换关卡的时候GameLnstance里的数据依然保留,需要在切换关卡保留的数据可以存放在GameLnstance GameModeGameMode如果在联网状态下是一个服务端(Server),客户端不能访问 GameSessionGameSession更像一个房间,让玩家进入,加入游戏,存在于服务端 GameStateGameState相当于一个全局的数据管理,在客户端也存在一份，可以和客户端实时同步,可以被客户端和服务端访问 PlayerControllerPlayerController是非常重要的,它关联着服务端和客户端,客户端是通过Controller来向服务端发请求,用它来控制Pawn包含: 输出响应控制 旁观者 替换角色 网络连接 GM命令 声音 语言 射线 客户端显示HUD 视口 相机管理 屏幕震动 作弊管理 客户端和服务端都存在 执行客户端逻辑和服务端逻辑请求 PlayerState掌管玩家的一些数据，一个角色的攻击力,防御力,Buff以及其他的一些数据,需要通过PlayerController来访问 PawnPawn也需要PlayerController来访问,Pawn其实是一个角色的表现,比如动画,模型以及其他组件,Pawn也是客户端和服务端都存在一份 HUDHUD只存在于客户端,服务端是没有这个东西的,用来做UMG或者Slate的管理 GameViewoirtClientGameViewoirtClient是一个游戏视口,在游戏中只存在于客户端,输出响应和渲染 GameUserSettingsGameUserSettings可以做些配置，自定义的一些配置 WorldSettings调节当前关卡的属性","categories":[{"name":"UE4","slug":"UE4","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/"},{"name":"笔记","slug":"UE4/笔记","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"https://mengxinxiaoqiang.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"UPROPERTY","slug":"Unreal-UPROPERTY","date":"2020-03-05T17:29:23.000Z","updated":"2020-03-06T06:05:57.908Z","comments":true,"path":"2020/03/06/Unreal-UPROPERTY/","link":"","permalink":"https://mengxinxiaoqiang.github.io/2020/03/06/Unreal-UPROPERTY/","excerpt":"UPROPERTYUPROPERTY 用途广泛,它允许变量被复制、被序列化，并可从蓝图中进行访问.垃圾回收器还使用它们来追踪对 UObject 的引用数.","text":"UPROPERTYUPROPERTY 用途广泛,它允许变量被复制、被序列化，并可从蓝图中进行访问.垃圾回收器还使用它们来追踪对 UObject 的引用数. 属性说明符声明属性时,属性说明符,可被添加到声明,以控制属性与引擎和编辑器诸多方面的相处方式. 1234567891011Category=\"TopCategory|SubCategory|...\" // 指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。UP::AdvancedDisplay // 属性将被放置在其出现的任意面板的高级（下拉）部分中。UP::AssetRegistrySearchable // 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用UP::BlueprintAssignable // 只能与组播委托共用。公开属性在蓝图中指定。UP::BlueprintAuthorityOnly // 此属性必须为一个组播委托。在蓝图中，其只接受带 BlueprintAuthorityOnly 标签的事件。UP::BlueprintCallable // 仅用于组播委托。应公开属性在蓝图代码中调用。UP::BlueprintReadOnly // 此属性可由蓝图读取，但不能被修改。此说明符与 BlueprintReadWrite 说明符不兼容。UP::BlueprintReadWrite // 可从蓝图读取或写入此属性。此说明符与 BlueprintReadOnly 说明符不兼容。UP::VisibleAnywhere // 说明此属性在所有属性窗口中可见，但无法被编辑。此说明符与“Edit”说明符不兼容。UP::VisibleDefaultsOnly // 说明此属性只在原型的属性窗口中可见，无法被编辑。此说明符与所有“Edit”说明符均不兼容。UP::VisibleInstanceOnly // 说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），无法被编辑。此说明符与所有“Edit”说明符均不兼容。 元数据说明符声明类,接口,结构体,列举,列举值,函数,或属性时,可添加 元数据说明符 来控制其与引擎和编辑器各方面的相处方式。每一种类型的数据结构或成员都有自己的元数据说明符列表。 12DisplayName=\"Property Name\" // 此属性显示的命名，不显示代码生成的命名。AllowPreserveRatio // 用于 Fvector 属性。在细节面板中显示此属性时将添加一个比率锁。 基本用法VisibleAnywhere12UPROPERTY(VisibleAnywhere, Category = \"Test\") bool Test; VisibleDefaultsOnly12UPROPERTY(VisibleDefaultsOnly, Category = \"Test\") bool Test; VisibleInstanceOnly12UPROPERTY(VisibleInstanceOnly, Category = \"Test\") bool Test; BlueprintReadWrite12UPROPERTY(BlueprintReadWrite, Category = \"Test\") bool Test; 官方链接","categories":[{"name":"UE4","slug":"UE4","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/"},{"name":"笔记","slug":"UE4/笔记","permalink":"https://mengxinxiaoqiang.github.io/categories/UE4/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"UPROPERTY","slug":"UPROPERTY","permalink":"https://mengxinxiaoqiang.github.io/tags/UPROPERTY/"}]}]}